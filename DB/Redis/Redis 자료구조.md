## Redis 자료구조

- 레디스에서 지원하는 자료 구조

### String

- 가장 기본적인 데이터 타입
- 바이트 배열 저장(*Binary-Safe)
    - Binary-Safe : 텍스트 인코딩, 특수문자, Null 등을 저장하더라도 내용이 임의로 변경되거나 해석되지 않음
- 바이너리로 변환 가능한 모든 데이터를 저장 가능
- 최대 크기 - 512MB

#### 명령어

|  명령어   |             기능             |           예제           |
|:------:|:--------------------------:|:----------------------:|
|  SET   |        특정 키에 문자열 저장        |      SET {키} {밸류}      |
|  GET   |      특정 키의 문자열 값을 로드       |        GET {키}         |
| **INCR | 특정 키의 값을 Integer 취급하여 1 증가 |        INCR {키}        |
| **DECR | 특정 키의 값을 Integer 취급하여 1 감소 |        DECR {키}        |
|  MSET  |     여러 키에 대한 값을 한번에 저장     | MSET {키} {밸류} {키} {밸류} |
|  MGET  |     여러 키에 대한 값을 한번에 로드     |      MGET {키} {키}      |

** : 값이 숫자로 변환 가능한 경우에만 작동

### List

- 한 밸류에 여러개의 값이 저장된 자료 구조
- Linked List 형태
- Queue와 Stack로 사용 가능

#### 명령어

|  명령어   |            기능            |         예제         |
|:------:|:------------------------:|:------------------:|
| LPUSH  |  리스트 왼쪽(Head)에 새로운 값 추가  | LPUSH {리스트} {데이터}  |
| RPUSH  | 리스트의 오른쪽(Tail)에 새로운 값 추가 | RPUSH {리스트} {데이터}  |
|  LLEN  |      리스트의 아이템 갯수 반환      |       LLEN {리스트}        |
| LRANGE |      리스트의 특정 범위 반환       | LRANGE {리스트} 0 -1 |
|  LPOP  |  리스트의 왼쪽(Head) 삭제 및 반환   |    LPOP {리스트}     |
|  RPOP  |  리스트의 오른쪽(Tail) 삭제 및 반환  |    RPOP {리스트}     |

리스트의 인덱스는 0 에서 시작하며 -1은 마지막 요소, -2는 마지막에서 두번째 요소

### Sets

- 순서가 없는 유니크한 값의 집합
- 검색이 빠름
- 개별 접근을 위한 인덱스가 존재하지 않음
- 집합연산 가능(교집합, 합집합 등)

#### 명령어

|    명령어    |           기능           |          예제          |
|:---------:|:----------------------:|:--------------------:|
|   SADD    |      Set에 데이터 추가       |   SADD {세트} {데이터}    |
|   SREM    |      Set에 데이터 삭제       |   SREM {세트} {데이터}    |
|   SCARD   |   Set에 저장된 아이템 갯수 반환   |      SCARD {세트}      |
| SMEMBERS  |    Set에 저장된 아이템 반환     |    SMEMBERS {세트}     |
| SISMEMBER | 특정 값이 Set에 포함되어 있는지 반환 | SISMEMBER {세트} {데이터} |
- SISMEMBER 명령은 Set의 크기에 상관없이 일정한 수행속도 보장
  - 특정 유저별로 1회만 사용 가능한 기능의 중복확인을 할 때 Set에 포함되어있는지 조회하는 방식의 응용도 가능

### Hashes
- 하나의 Key 하위에 여러개의 Field-Value 쌍을 저장
- 여러 필드를 가진 객체를 저장하는 것으로 생각 할 수 있음

#### 명령어

|   명령어   |               기능                |              예제              |
|:-------:|:-------------------------------:|:----------------------------:|
|  HSET   |      한 개 또는 다수의 필드에 값을 저장       | HSET {키} {필드} {밸류} {필드} {밸류} |
|  HGET   |          특정 필드의 값을 반환           |        HGET {키} {필드}         |
|  HMGET  |        한 개 이상의 필드 값을 반환         |     HMGET {키} {필드} {필드}      |
| HINCRBY | 특정 필드 값을 Integer 취급하여 원하는 만큼 증가 |     HINCRBY {키} {필드} {값}     |
|  HDEL   |          한 개 이상의 필드 삭제          |      HDEL {키} {필드} {필드}      |
- HINCRBY 명령어가 필드에 존재하지 않는 경우 새로 만들어서 1 증가
  - 해당 명령어를 이용하여 카운터로 사용 가능

### Sorted Sets
- Set과 유사하게 유니크한 값의 집합
- 각 값은 연관된 score를 가지고 정렬되어 있음
- 정렬된 상태이기에 빠르게 최소 / 최대 값을 구할 수 있음

#### 명령어

|   명령어    |          기능           |                                예제                                 |
|:--------:|:---------------------:|:-----------------------------------------------------------------:|
|   ZADD   |   한 개 또는 다수의 값 업데이트   | ZADD {키} {스코어} {멤버} {스코어} {멤버}<br/>ZADD myrank 10 apple 20 banana |
|  ZRANGE  |   특정 범위 값 반환(오름차순)    |        ZRANGE {키} {시작 인덱스} {종료 인덱스}<br/>ZRANGE myrank 0 1         |
|  ZRANK   | 특정 값의 위치(순위) 반환(오름차순) |                          ZRANK {키} {멤버}                           |
| ZREVRANK |   특정 값의 위치 반환(내림차순)   |                         ZREVRANK {키} {멤버}                         |
|   ZREM   |     한 개 이상의 값을 삭제     |                           ZREM {키} {멤버}                           |
- 순위 계산, 리더보드의 구현에 활용 가능

### Bitmaps
- 비트 벡터를 사용해 N개의 Set을 공간 효율적으로 저장
- 하나의 비트맵이 가지는 공간은 4,294,967,295(2^32-1)(약 43억)

#### 명령어

|   명령어   |              기능               |                        예제                         |
|:-------:|:-----------------------------:|:-------------------------------------------------:|
|  SETBIT |      비트맵의 특정 오프셋에 값을 변경       | SETBIT {키} {오프셋} {값 - 0 or 1}<br/>SETBIT key 10 1 |
|  GETBIT |      비트맵의 특정 오프셋의 값을 반환       |                 GETVIT {키} {오프셋}                  |
| BITCOUNT |  비트맵에서 set(1) 상태인 비트의 개수를 반환  |                   BITCOUNT {키}                    |
|  BITOP  | 비트맵들간 비트 연산을 수행하고 결과를 비트맵에 저장 |          BITTOP {연산} {결과 저장용 키} {키} {키}<br/>BITOP AND resultbitmap bitmap1 bitmap2 bitmap3           |

### HyperLogLog
- 유니크한 값의 개수를 효율적으로 얻을 수 있음
- 확률적 자료구조(완벽한 정확도는 아님)로서 오차가 존재하여 매우 큰 데이터를 다룰 때 사용
- 18,446,744,073,709,551,616(2^64)개의 유니크 값을 계산 가능
- 12KB 까지 메모리를 사용하여 0.81% 오차율을 허용
- 값을 추가해도 저장하는것은 아님

#### 명령어

|   명령어   |                 기능                  |                  예제                   |
|:-------:|:-----------------------------------:|:-------------------------------------:|
|  PFADD  |              HyperLogLog에 값들을 추가              |         PFADD {키} {데이터} {데이터}         |
| PFCOUNT | HyperLogLog에 입력된 값들의 Cardinality(고유 값의 수)를 반환 |              PFCOUNT {키}              |
| PFMERGE |           다수의 HyperLogLog 병합           | PFMERGE {결과 저장용 키} {대상 키} {대상키} {대상키} |
